# Gitの操作

## Gitの基本的な仕組み
 ローカルは、3つのエリアに分かれている
 + ワークツリー
 + ステージ
 + リポジトリ

### ワークツリー
 手元のファイルの作業場

### ステージ
 コミットする変更を準備する変更
 コミット = スナップショットの記録

### リポジトリ
 スナップショットを記録する場

## この仕組みの裏側は???
 index.htmlをバージョン管理するとする。
 リポジトリには、圧縮ファイルA(index.html)のファイル内容を圧縮)を作成する。

 ステージ上のインデックス上では、index.htmlのファイル構成を記録する。

 ツリーを構成する ＆ コミットを作成する 
 コミットには、ツリーと作成者、日時などを作成する。

### もし新しいファイルが追加されたら...
 圧縮ファイルB(css/home.css)が作成されたとする。

 ステージ上のインデックス上では、index.htmlとcss/home.cssのファイル構成を記録する。
 
 ツリー2(圧縮ファイル A と B)を構成する ＆ コミット2 (ツリー2 親コミット1 作成者 日付 コミットメッセージ) を作成する 
 コミットには、ツリーと作成者、日時などを作成する。

### ファイルを変更したら 
 圧縮ファイルC(css/home.css)が作成されたとする。

 ステージ上のインデックスでは、圧縮ファイルC (index.html)とcss/home.cssのファイル構成を記録する。
 
 ツリー3(圧縮ファイル C と B)を構成する ＆ コミット (ツリー3 親コミット2 作成者 日付 コミットメッセージ) を作成する 
 コミットには、ツリーと作成者、日時などを作成する。
 
## より正確な話
 圧縮ファイルというのは、「blob(ブロブ)オブジェクト 」という。 blobというのは、「カタマリ」という意味です。ファイルの中身を圧縮しただけのカタマリということになる。

 また、圧縮ファイルのファイル名は、実際は、ハッシュIdのことを指す。ヘッダー(ファイルの内容の文字数やファイルのメタ情報)とファイル内容をSHA-1というハッシュ関数(英数字40文字以上)で変換したもの。

 ハッシュIDというのは、ファイルの中身に対して一意になるということです。中身が同じファイルであれば必ず同じハッシュIDになります。そのため、ファイルの中身が同じであれば git add しても追加で圧縮ファイルが作られることはありませんし、ファイルの中身に変更があれば git add すると別の圧縮ファイルが作成されます。

 ツリーファイルは一つのディレクトリに対応していて、ツリーファイルの中にツリーファイルと圧縮ファイルが含まれるようになっています。

# Gitのコマンド(新規学習分)
 ## 変更差分を確認する。
 ```
 # git addする前の変更分
 git diff
 git diff <ファイル名>

 # git addした後の変更分
 git diff --stagerd
 ## 変更差分を確認する。
 ```
 ## ファイルの変更履歴を確認する
 ```
 # git 
 git log
 # 一行で表示する
 git log --oneline
 # ファイルの変更差分を表示する
 git log -p index.html
 ```
 ## ファイルの消去を確認する
 ```
 # ファイルを消去 ワークツリー上も消去
 git rm <ファイル名>
 # ファイルを残したいとき ワークツリーは消去しない
 git rm --cached <ファイル名>
 ```

 ## バージョン管理しないファイルの無視

 .gitignoreを作成する。 

 ## ファイルへの変更を取り消す
 ステージの段階を反映さえ消去する。
 ```
 git checkout -- <ファイル名>
 git checkout -- <ディレクトリ名>
 
 #全変更を取り消す
 git checkout --

 #"--"とつけているのは、ブランチ名とファイル名がかぶったときに、
 どちらを指しているのがGitがわからなくなるのを避けるため。
 ```
 ## ステージした変更を取り消す
指定した変更をステージから取り出すだけなので、ワークツリーのファイルには、影響ない。

仕組みは、リポジトリから最新のコミットの情報を持ってきてその内容をステージの内容を上書きする
 ```
 git reset HEAD <ファイル名>
 git reset HEAD <ディレクトリ名>

 #全変更を取り消す
 git reest HEAD
 ```

 ## 直前のコミットをやり直す
これは、push前のみ使用が可能。使用後は、コミットをして修正が必要。

 ``` 
 git commit --amend 
 ```

 ## リモートから情報を取得する(フェッチ ＆ マージ)

 リモートリポジトリからローカルリポジトリへ保存する。
 保存先は、(remotes/リモート名/ブランチ名)
 
 その後マージをするとワークツリーへ反映することができる。

 ```
 # 詳細を知りたい場合
  git remote show origin
 ```

 ## リモートを変更する・消去する
+ リモート名を変更する 
 ```
 git remote rename <旧リモート名> <新リモート名>

 #example 
 git remote rename tutorial new_tutorial
 ```
 + リモート名を削除する
 ```
 git remote rm <リモート名>

 #example 
 git remote rm tutorial new_tutorial
 ```
## ブランチとマージ

並行して複数機能を開発するためにあるのがブランチ
ブランチは分岐して開発するもの

### ブランチの仕組み
 Gitのデータの持ち方
 
 コミットは、 tree と author の2つが中身ファイル名はハッシュで構成されている。

 コミットは、スナップショット。それが時系列順に連なる。

  **ブランチはコミットを指したポインタ**
 
 例えば... コミット1, 2, 3 がありコミット3のコミットファイルをmasterというブランチ名が指している。

 + HEAD  今作業中のブランチを指示している。
 masterブランチで作業し新たにコミットしたらブランチが指すコミットファイルが変わる。
 
 ブランチは、開発を分岐させることができ並行して進めることができる。

### ブランチとHEADの中身

コミット 4 ブランチ名 master と コミット 5 feature があるとする。 コミット4は、 12345 コミット5は、 67890とするとブランチというのは、単なるコミットIDを記録したポインタである。

コミット4 を指示している`master` は、12345を記録し、コミット5を指し示している`feature` は、67890を記録することになる。

HEADは、現在作業中のブランチへのポインタを指し示している。
HEADの中身は、`ref feature` というようにブランチ名が格納されている。

## 新しいブランチを作成する。

```
git branch <ブランチ名>
#example 
git branch feature 
```

ブランチを入力してもHEADなどは移動しない。ブランチの切り替えは行われない。


```
git checkout <既存ブランチ名>
#example 
git checkout feature

# ブランチを新規作成して切り替える 一度に新規作成＆切り替え可能
git checkout -b <新ブランチ名>
```
どのブランチに保存されるかは、HEADで指定され `git add . ` をするタイミングで
決定する。

## 変更をマージをする

```
git merge <ブランチ名>
git merge <リモート名/ブランチ名>
#example 
git origin main 
```
マージには3種類ある
+ Fast Foward : 早送りになるマージ
 masterがa6923というコミットを指しているとする。 そこに修正コミットである23q1aにブランチ名hotfixがコミットを指し示しているとする。そこで `git merge hotfix` をするとブランチが枝分かれしてなかったときは、ブランチのポインタを前に進めるだけ

+ Auto Merge : 基本的なマージ
  masterがa6923というコミットを指しているとする。 そこにペアレントコミットが2つある場合、それらを統合し、一つのコミットを新たに生成する。

### コンフリクトが起きた場合
 コンフリクトは、同一ファイルの同一行で異なるブランチで異なる変更をした際におこることで、この状態で`merge` をすると以下のようなファイルが生成される。
 確認する方法は、 `git status` を見ることで、どれが変更されたかわかる。

 ```
 <<<HEAD 
  ========

 >>> feature
 ```

 ## ブランチを変更する/削除する
 いま、自分が作業しているブランチの名前を変更する場合
 ```
 git branch -m <ブランチ名>
 
 git branch -m new_branch
 ```

また削除したい場合、
 
 ```
 git branch -d <ブランチ名>
 
 git branch -d new_branch

 # 強制削除する
 git branch -D <ブランチ名>
 ```

 masterにマージされていない変更が残っている場合は削除しない。

 ## プルリクエスト
 プルリクエストは、自分の変更したコードをリポジトリに取り込んでもらえるよう依頼する機能

 レビューを挟まないとバグが発生したりコードの質が低下する恐れがある。

 例えば...
 6. プルリクエストを送る
 7. コードレビュー
 8. プルリクエストをmasterブランチへマージ

 ブランチ名を例えば `git pull -b pull_request` を作成し、変更をした。
 プルリクエストをするには、Githubから new pull requestを選択。 baseブランチ <- compareブランチ コードレビューするには、Reviewers を選択。 Reviewerは、Files changed をすると比較できる。

 ## GitHub Flow 
 GitHub社が行っているフロー

+ masterブランチからブランチを作成。。
+ ファイルを変更しコミット
+ 同名のブランチをGitHubへプッシュ
+ プルリクエストを送る
+ コードレビューし、masterブランチにマージ
+ masterブランチをデプロイ

約束事
+ 新開発は、masterブランチから新しいブランチを作成してスタート
+ 作成した新しいブランチ上で作業しコミットをする。
+ masterにマージするためにプルリクエストを使う

## リベースとは??
変更を統合する際に、履歴を整えた形で変更を統合する。

```
git rebase <ブランチ名>
```

コミット1(親) , コミット1を参照コミット2(master) , コミット1を参照コミット3(feature)だとする。ここで`rebase master`をするとコミット3がコミット2を参照しコミット3'を生成する。コミット3は消去する。

### リベースとマージて何が違うの？？？

マージコミットは、

コミット1(親) , コミット1を参照コミット2(master) , コミット1を参照コミット3(feature)だとする。ここで`merge master`をするとコミット3がコミット2を参照しコミット4を生成する。

GitHubにプッシュしたコミットをリベースするのはNG
なので、プッシュしていないローカルの変更には、リベースを使い、プッシュした後はマージを使う。コンフリクトしそうならマージを使う

マージコミットが特に必要ではなく最新のデータだけ取得したい場合は、
```
git pull --rebase origin master
```
のように入力をする。

## 複数のコミットをやり直す

```
git rebase -i <コミットID>
git rebase -i HEAD~3
```

HEAD~ 一番の親を指定する。HEADを起点にして数値分の親コミットまで指定する。

HEAD^ マージした場合の2番目の親を指定する。

### どういうときに使うのがよい???
軽微な修正の時に、複数のコミットが必要ないとき、

例えば、、、日報で些細な誤字脱字をしてしまった場合。
```
pick c2d2fa7 日報 23/01/16　
pick a4c76c3 日報 23/01/16 fix2　
pick 66e728d 日報 23/01/16 fix3　
pick cba3fc0 日報 23/01/16 fix4　

```
これを
```
s c2d2fa7 日報 23/01/16　
s a4c76c3 日報 23/01/16 fix2　
s 66e728d 日報 23/01/16 fix3　
  cba3fc0 日報 23/01/16 fix4　
```

これをするとコミットを一つにまとめることができる。